#include <iostream>
#include <vector>
#include <zmq.hpp>
#include <opencv2/opencv.hpp>
#include <chrono>
#include <filesystem>
#include <iomanip>
#include "scanner_darkly_effect.hpp"
#include "ImageStructure.hpp"

namespace fs = std::filesystem;

class Worker {
private:
    zmq::context_t context;
    zmq::socket_t pull_socket;
    std::string worker_id;
    fs::path temp_dir;
    ScannerDarklyEffect effect;
    
    // Папки для сохранения изображений
    fs::path raw_dir;
    fs::path processed_dir;
    size_t frame_counter = 0;

public:
    Worker() : context(1), pull_socket(context, ZMQ_PULL) {
        // Подключение к Capturer (PULL)
        std::vector<std::string> connect_addresses = {
            "tcp://localhost:5555",
            "tcp://127.0.0.1:5555",
            "tcp://192.168.9.61:5555",
            "tcp://192.168.1.61:5555"
        };

        bool connected = false;
        for (const auto& address : connect_addresses) {
            try {
                pull_socket.connect(address);
                std::cout << "Worker connected to Capturer: " << address << std::endl;
                connected = true;
                break;
            }
            catch (const zmq::error_t& e) {
                std::cout << "Failed to connect to Capturer " << address << ": " << e.what() << std::endl;
            }
        }

        if (!connected) {
            throw std::runtime_error("Failed to connect to any Capturer address");
        }

        // Создаем уникальный ID для воркера
        auto now = std::chrono::system_clock::now();
        auto time_t_now = std::chrono::system_clock::to_time_t(now);
        std::tm tm_now = *std::localtime(&time_t_now);
        
        std::stringstream ss;
        ss << "worker_" << std::put_time(&tm_now, "%Y%m%d_%H%M%S");
        worker_id = ss.str();

        // Создаем основную временную папку
        temp_dir = fs::current_path() / worker_id;
        raw_dir = temp_dir / "raw";
        processed_dir = temp_dir / "processed";

        // Создаем структуру папок
        fs::create_directories(raw_dir);
        fs::create_directories(processed_dir);

        std::cout << "Worker ID: " << worker_id << std::endl;
        std::cout << "Temp directory: " << temp_dir << std::endl;
        std::cout << "Raw frames directory: " << raw_dir << std::endl;
        std::cout << "Processed frames directory: " << processed_dir << std::endl;

        // Настройка эффекта для ЧЕРНЫХ ТОНКИХ контуров
        effect.setCannyThresholds(60, 160);
        effect.setGaussianKernelSize(3);
        effect.setDilationKernelSize(0);
        effect.setColorQuantizationLevels(8);
        effect.setBlackContours(true);

        std::cout << "Worker initialized with Scanner Darkly effect" << std::endl;
        std::cout << "======================================================" << std::endl;
    }

private:
    // Сохранение исходного изображения
    void save_raw_image(const cv::Mat& image, size_t frame_id) {
        std::stringstream filename;
        filename << "frame_" << std::setfill('0') << std::setw(6) << frame_id << ".jpg";
        fs::path filepath = raw_dir / filename.str();
        
        std::vector<int> compression_params = {cv::IMWRITE_JPEG_QUALITY, 85};
        if (cv::imwrite(filepath.string(), image, compression_params)) {
            std::cout << "- [ OK ] Saved raw frame: " << frame_id << " to " << filename.str() << std::endl;
        } else {
            std::cout << "- [FAIL] Failed to save raw frame: " << frame_id << std::endl;
        }
    }

    // Сохранение обработанного изображения
    void save_processed_image(const cv::Mat& image, size_t frame_id) {
        std::stringstream filename;
        filename << "processed_" << std::setfill('0') << std::setw(6) << frame_id << ".jpg";
        fs::path filepath = processed_dir / filename.str();
        
        std::vector<int> compression_params = {cv::IMWRITE_JPEG_QUALITY, 85};
        if (cv::imwrite(filepath.string(), image, compression_params)) {
            std::cout << "- [ OK ] Saved processed frame: " << frame_id << " to " << filename.str() << std::endl;
        } else {
            std::cout << "- [FAIL] Failed to save processed frame: " << frame_id << std::endl;
        }
    }

    // Показ превью изображений
    void show_preview(const cv::Mat& original, const cv::Mat& processed, size_t frame_id) {
        // Создаем окна при первом вызове
        static bool windows_created = false;
        if (!windows_created) {
            cv::namedWindow("Worker - Original", cv::WINDOW_NORMAL);
            cv::namedWindow("Worker - Processed", cv::WINDOW_NORMAL);
            cv::resizeWindow("Worker - Original", 640, 480);
            cv::resizeWindow("Worker - Processed", 640, 480);
            windows_created = true;
        }
        
        // Добавляем текст с информацией о кадре
        cv::Mat original_with_text = original.clone();
        cv::Mat processed_with_text = processed.clone();
        
        std::string text = "Frame: " + std::to_string(frame_id);
        cv::putText(original_with_text, text, cv::Point(10, 30), 
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        cv::putText(processed_with_text, "Scanner Darkly: " + text, cv::Point(10, 30), 
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        
        // Показываем изображения
        // cv::imshow("Worker - Original", original_with_text);
        // cv::imshow("Worker - Processed", processed_with_text);
        
        // // Обработка нажатия клавиш
        // int key = cv::waitKey(1);
        // if (key == 27) { // ESC
        //     std::cout << "ESC pressed, exiting..." << std::endl;
        //     throw std::runtime_error("User requested exit");
        // }
    }

public:
    void run() {
        std::cout << "=== Worker Started ===" << std::endl;
        std::cout << "Processing frames with Scanner Darkly effect..." << std::endl;
        std::cout << "Press ESC in preview window to exit" << std::endl;
        std::cout << "======================================================" << std::endl;

        size_t frames_processed = 0;
        auto start_time = std::chrono::steady_clock::now();

        while (true) {
            try {
                zmq::message_t msg;
                
                // Получаем сообщение
                auto recv_result = pull_socket.recv(msg, zmq::recv_flags::none);
                
                if (recv_result) {
                    frame_counter++;
                    auto frame_time = std::chrono::steady_clock::now();
                    
                    // Десериализация как в srv_recv.cpp
                    cv::Mat received_image;
                    
                    // Создаем ImageStructure и десериализуем
                    ImageStructure img_struct(received_image);
                    std::string serialized_data = msg.to_string(); // Конвертируем в строку
                    img_struct.deserialize(serialized_data);
                    
                    size_t frame_id = img_struct.id;
                    
                    std::cout << "\n--- Processing Frame " << frame_id << " (Worker #" << frame_counter << ") ---" << std::endl;
                    std::cout << "Received size: " << msg.size() << " bytes" << std::endl;
                    std::cout << "Image size: " << received_image.cols << "x" << received_image.rows << std::endl;
                    std::cout << "Image type: " << received_image.type() << std::endl;
                    std::cout << "Channels: " << received_image.channels() << std::endl;
                    
                    // Проверяем, что изображение корректно
                    if (received_image.empty()) {
                        std::cout << "- [WARN] Received empty image, skipping..." << std::endl;
                        continue;
                    }
                    
                    // Сохраняем исходное изображение
                    save_raw_image(received_image, frame_id);
                    
                    // Применяем эффект Scanner Darkly
                    cv::Mat processed_image;
                    try {
                        processed_image = effect.applyEffect(received_image);
                        
                        if (!processed_image.empty()) {
                            // Сохраняем обработанное изображение
                            save_processed_image(processed_image, frame_id);
                            
                            // Показываем превью
                            show_preview(received_image, processed_image, frame_id);
                            
                            frames_processed++;
                            
                            // Вывод статистики каждые 10 кадров
                            if (frames_processed % 10 == 0) {
                                auto current_time = std::chrono::steady_clock::now();
                                auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(current_time - start_time).count();
                                if (elapsed > 0) {
                                    double fps = static_cast<double>(frames_processed) / elapsed;
                                    std::cout << "\n=== Statistics ===" << std::endl;
                                    std::cout << "Frames processed: " << frames_processed << std::endl;
                                    std::cout << "Elapsed time: " << elapsed << " seconds" << std::endl;
                                    std::cout << "Processing FPS: " << fps << std::endl;
                                    std::cout << "Raw images in: " << raw_dir << std::endl;
                                    std::cout << "Processed images in: " << processed_dir << std::endl;
                                    std::cout << "======================================================" << std::endl;
                                }
                            }
                            
                        } else {
                            std::cout << "- [WARN] Processed image is empty" << std::endl;
                        }
                        
                    } catch (const std::exception& e) {
                        std::cout << "- [FAIL] Error applying Scanner Darkly effect: " << e.what() << std::endl;
                    }
                }
                
            } catch (const zmq::error_t& e) {
                if (e.num() != EINTR) {
                    std::cout << "- [FAIL] ZMQ error: " << e.what() << std::endl;
                }
                break;
            } catch (const std::exception& e) {
                std::string error_msg = e.what();
                if (error_msg == "User requested exit") {
                    std::cout << "Exiting as requested by user..." << std::endl;
                    break;
                }
                std::cout << "- [FAIL] Processing error: " << error_msg << std::endl;
            }
        }
        
        // Вывод итоговой статистики
        auto end_time = std::chrono::steady_clock::now();
        auto total_time = std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time).count();
        
        std::cout << "\n======================================================" << std::endl;
        std::cout << "Worker stopped" << std::endl;
        std::cout << "Total frames received: " << frame_counter << std::endl;
        std::cout << "Total frames processed: " << frames_processed << std::endl;
        std::cout << "Total time: " << total_time << " seconds" << std::endl;
        if (total_time > 0) {
            std::cout << "Average FPS: " << static_cast<double>(frames_processed) / total_time << std::endl;
        }
        std::cout << "Images saved in: " << temp_dir << std::endl;
        std::cout << "======================================================" << std::endl;
        
        // Закрываем окна OpenCV
        cv::destroyAllWindows();
    }
};

int main() {
    try {
        Worker worker;
        worker.run();
        return 0;
    } catch (const std::exception& e) {
        std::cout << "\n======================================================" << std::endl;
        std::cout << "- [FAIL] Worker error: " << e.what() << std::endl;
        std::cout << "======================================================" << std::endl;
        cv::destroyAllWindows();
        return -1;
    }
}